/**
 * VULCA Gallery Hero Renderer
 * js/gallery-hero.js - v1.0.0
 *
 * Renders the active artwork and critic reviews to the homepage
 * Listens to carousel navigation events and updates DOM
 */

window.GalleryHeroRenderer = (function() {
  'use strict';

  const CONFIG = {
    MAX_CRITICS_VISIBLE: 6,  // Show all 6 critics
    CRITIC_TEXT_PREVIEW: 150, // Characters to show in preview (reduced for expand/collapse)
  };

  /**
   * Smart text truncation at sentence boundaries
   * @param {string} text - Full text
   * @param {number} maxLength - Maximum characters (default 150)
   * @returns {string} - Truncated text with "..."
   */
  function truncateText(text, maxLength = 150) {
    if (!text || text.length <= maxLength) return text;

    const truncated = text.substring(0, maxLength);
    const lastPeriod = truncated.lastIndexOf('„ÄÇ');
    const lastComma = truncated.lastIndexOf('Ôºå');

    const breakPoint = Math.max(lastPeriod, lastComma);

    // Use sentence boundary if found after 50 chars
    return breakPoint > 50
      ? text.substring(0, breakPoint + 1) + '...'
      : truncated + '...';
  }

  /**
   * Toggle critique expansion state
   * Now supports HTML content with image reference links
   * @param {HTMLElement} card - Critique card element
   * @param {HTMLElement} textElement - Text paragraph element
   * @param {HTMLElement} button - Toggle button element
   */
  function toggleCritiqueExpansion(card, textElement, button) {
    const isExpanded = card.classList.contains('expanded');

    // Check if processed HTML is available
    const hasProcessedHTML = card.dataset.fullTextProcessed;
    const hasPlainText = card.dataset.fullTextPlain;

    if (isExpanded) {
      // Collapse
      card.classList.remove('expanded');

      if (hasProcessedHTML) {
        textElement.innerHTML = card.dataset.truncatedProcessed;
      } else if (hasPlainText) {
        textElement.textContent = truncateText(card.dataset.fullTextPlain, 150);
      }

      button.textContent = 'Â±ïÂºÄ ‚ñº';
      button.setAttribute('aria-expanded', 'false');
      button.setAttribute('aria-label', 'Â±ïÂºÄËØÑËÆ∫ÂÖ®Êñá');
    } else {
      // Expand
      card.classList.add('expanded');

      if (hasProcessedHTML) {
        textElement.innerHTML = card.dataset.fullTextProcessed;
      } else if (hasPlainText) {
        textElement.textContent = card.dataset.fullTextPlain;
      }

      button.textContent = 'Êî∂Ëµ∑ ‚ñ≤';
      button.setAttribute('aria-expanded', 'true');
      button.setAttribute('aria-label', 'Êî∂Ëµ∑ËØÑËÆ∫');
    }

    // Re-attach click handlers after content change
    if (hasProcessedHTML) {
      setTimeout(() => {
        const links = textElement.querySelectorAll('.image-reference-link');

        links.forEach(link => {
          link.addEventListener('click', (e) => {
            e.preventDefault();
            const imageId = link.dataset.imageId;

            // Find artwork from parent card's data
            const artworkId = card.dataset.artworkId;
            const artwork = window.VULCA_DATA?.artworks?.find(a => a.id === artworkId);

            if (artwork) {
              handleImageReferenceClick(imageId, artwork);
            } else {
              console.warn('[Gallery Hero] Artwork not found for:', artworkId);
            }
          });
        });

        console.log(`[Gallery Hero] Re-attached ${links.length} handlers after ${isExpanded ? 'collapse' : 'expand'}`);
      }, 0);
    }
  }

  /**
   * Truncate HTML content while preserving tags
   *
   * This function is specifically designed to handle HTML generated by
   * CritiqueParser.renderImageReferences(), which contains <a> tags.
   * It ensures links are not broken during truncation.
   *
   * @param {string} html - HTML content with image reference links
   * @param {number} maxLength - Maximum text length (default: 150)
   * @returns {string} Truncated HTML with properly closed tags
   */
  function truncateHTML(html, maxLength = 150) {
    if (!html || typeof html !== 'string') return '';

    // Extract plain text for length calculation
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = html;
    const plainText = tempDiv.textContent || tempDiv.innerText || '';

    // If under limit, return original
    if (plainText.length <= maxLength) {
      return html;
    }

    // Truncate plain text at sentence boundary (reuse existing logic)
    const truncatedPlain = truncateText(plainText, maxLength);
    const targetLength = truncatedPlain.length - 3; // Exclude "..."

    // Find corresponding position in HTML
    let charCount = 0;
    let resultHTML = '';
    let inTag = false;
    let tagStack = [];

    for (let i = 0; i < html.length; i++) {
      const char = html[i];

      if (char === '<') {
        inTag = true;
        // Look ahead to see if it's opening or closing tag
        if (html[i + 1] !== '/') {
          // Opening tag - will need to close it
          const tagEnd = html.indexOf('>', i);
          const tagName = html.substring(i + 1, tagEnd).split(' ')[0];
          if (tagName && tagName !== 'br' && tagName !== 'img') {
            tagStack.push(tagName);
          }
        } else {
          // Closing tag
          tagStack.pop();
        }
      }

      if (!inTag) {
        charCount++;
      }

      if (charCount >= targetLength) {
        resultHTML = html.substring(0, i + 1);
        break;
      }

      if (char === '>') {
        inTag = false;
      }
    }

    // Close any open tags in reverse order
    while (tagStack.length > 0) {
      const tag = tagStack.pop();
      resultHTML += `</${tag}>`;
    }

    // Add ellipsis
    resultHTML += '...';

    return resultHTML;
  }

  /**
   * Initialize the gallery hero renderer
   */
  function init() {
    const carousel = window.carousel;
    const galleryHero = document.getElementById('gallery-hero');

    if (!carousel || !galleryHero) {
      console.error('‚ùå Carousel or gallery-hero element not found');
      return;
    }

    // Initial render
    render(carousel);

    // Listen to carousel navigation events
    carousel.on('navigate', (event) => {
      render(carousel);
    });

    console.log('‚úì Gallery hero renderer initialized');
  }

  /**
   * Render current artwork and critics
   */
  function render(carousel) {
    renderHeroTitle(carousel);
    renderArtworkHeader(carousel);
    renderArtworkImage(carousel);
    renderCritiques(carousel);
    updateIndicator(carousel);
    renderDots(carousel);
  }

  /**
   * Render hero section title and description
   */
  function renderHeroTitle(carousel) {
    const galleryHero = document.getElementById('gallery-hero');
    if (!galleryHero) return;

    // Check if hero title already exists
    let heroTitle = galleryHero.querySelector('.hero-title-section');
    if (!heroTitle) {
      heroTitle = document.createElement('div');
      heroTitle.className = 'hero-title-section';
      galleryHero.insertBefore(heroTitle, galleryHero.firstChild);
    }

    heroTitle.innerHTML = '';

    const title = document.createElement('h1');
    title.className = 'hero-title';
    title.lang = 'zh';
    title.textContent = 'ÊΩÆÊ±êÁöÑË¥üÂΩ¢';

    const subtitle = document.createElement('p');
    subtitle.className = 'hero-subtitle';
    subtitle.lang = 'zh';
    subtitle.textContent = '‰∏ÄÂú∫ÂÖ≥‰∫éËâ∫ÊúØËØÑËÆ∫ÁöÑËßÜËßí‰πãÊóÖ';

    heroTitle.appendChild(title);
    heroTitle.appendChild(subtitle);

    console.log('‚úì Rendered hero title section');
  }

  /**
   * Render artwork header with title, year, and metadata
   */
  function renderArtworkHeader(carousel) {
    const galleryHero = document.getElementById('gallery-hero');
    if (!galleryHero) return;

    const artwork = carousel.getCurrentArtwork();
    if (!artwork) return;

    // Check if artwork header already exists
    let artworkHeader = galleryHero.querySelector('.artwork-header-section');
    if (!artworkHeader) {
      artworkHeader = document.createElement('div');
      artworkHeader.className = 'artwork-header-section';
      const artworkDisplay = galleryHero.querySelector('.artwork-display');
      if (artworkDisplay) {
        // Insert BEFORE artwork-display (as sibling, not child)
        galleryHero.insertBefore(artworkHeader, artworkDisplay);
      } else {
        galleryHero.appendChild(artworkHeader);
      }
    }

    artworkHeader.innerHTML = '';

    // Title
    const title = document.createElement('h2');
    title.className = 'artwork-title';

    const titleZh = document.createElement('span');
    titleZh.lang = 'zh';
    titleZh.textContent = artwork.titleZh;

    const titleEn = document.createElement('span');
    titleEn.lang = 'en';
    titleEn.textContent = artwork.titleEn;

    title.appendChild(titleZh);
    title.appendChild(document.createElement('br'));
    title.appendChild(titleEn);

    artworkHeader.appendChild(title);

    // Year and artist info
    const metadata = document.createElement('div');
    metadata.className = 'artwork-meta';

    const year = document.createElement('time');
    year.className = 'artwork-year';
    year.dateTime = artwork.year;
    year.textContent = `${artwork.year}`;

    const artist = document.createElement('span');
    artist.className = 'artwork-artist';
    artist.textContent = artwork.artist || 'Sougwen Chung';

    metadata.appendChild(year);
    metadata.appendChild(document.createTextNode(' ‚Ä¢ '));
    metadata.appendChild(artist);

    artworkHeader.appendChild(metadata);

    console.log(`‚úì Rendered artwork header: ${artwork.titleZh}`);
  }

  /**
   * Render artwork image (with multi-image carousel support)
   */
  function renderArtworkImage(carousel) {
    const container = document.getElementById('artwork-image-container');
    if (!container) return;

    const artwork = carousel.getCurrentArtwork();
    if (!artwork) return;

    // Clear previous content
    container.innerHTML = '';

    // Check if artwork uses new multi-image format
    if (window.ImageCompat && window.ArtworkImageCarousel) {
      const images = window.ImageCompat.getArtworkImages(artwork);

      // If artwork has multiple images, use carousel
      if (images.length > 1) {
        console.log(`‚úì Rendering multi-image carousel for: ${artwork.titleZh} (${images.length} images)`);

        // Create carousel
        const artworkCarousel = new window.ArtworkImageCarousel(artwork, container, {
          loop: true,
          preloadAdjacent: true,
          enableKeyboard: true,
          enableTouch: true,
          showMetadata: true,
          showIndicators: true,
          showNavigation: true,
          categoryBadges: true
        });

        artworkCarousel.render();

        // Highlight images referenced in current critiques (if any)
        const currentCritiques = window.VULCA_DATA?.critiques?.filter(c => c.artworkId === artwork.id) || [];
        const referencedImageIds = new Set();
        currentCritiques.forEach(critique => {
          if (critique.imageReferences) {
            critique.imageReferences.forEach(id => referencedImageIds.add(id));
          }
        });

        if (referencedImageIds.size > 0) {
          artworkCarousel.highlightImages(Array.from(referencedImageIds));
        }

        return;
      }
    }

    // Fallback: single image display (legacy format or single-image artwork)
    const figure = document.createElement('figure');
    figure.className = 'artwork-image';

    // Get image URL from images array (supports both new and legacy formats)
    const images = window.ImageCompat ? window.ImageCompat.getArtworkImages(artwork) : [];
    const imageUrl = images.length > 0 ? images[0].url : artwork.imageUrl;

    // Create image
    const img = document.createElement('img');
    img.src = imageUrl;
    img.alt = `${artwork.titleZh} ${artwork.titleEn}`;
    img.loading = 'eager';

    // Add error handler for missing images (Phase 1: fix-artwork-image-display-system)
    img.onerror = () => {
      console.warn(`‚ö† Image not found: ${imageUrl} (${artwork.id})`);
      container.innerHTML = '';
      const placeholder = createPlaceholder(artwork);
      container.appendChild(placeholder);
      console.log(`‚úì Displaying placeholder for: ${artwork.titleZh}`);
    };

    figure.appendChild(img);
    container.appendChild(figure);

    console.log(`‚úì Rendering single artwork image: ${artwork.titleZh}`);
  }

  /**
   * Create placeholder for missing artwork image
   * Phase 1 implementation of fix-artwork-image-display-system
   */
  function createPlaceholder(artwork) {
    const div = document.createElement('div');
    div.className = `artwork-placeholder ${artwork.id}`;
    div.setAttribute('role', 'img');
    div.setAttribute('aria-label',
      `${artwork.titleZh} ${artwork.titleEn}, ${artwork.artist}, ${artwork.year}, Image Pending Acquisition`
    );

    div.innerHTML = `
      <div class="placeholder-content">
        <h3 class="placeholder-title" lang="zh">${artwork.titleZh}</h3>
        <p class="placeholder-title-en" lang="en">${artwork.titleEn}</p>
        <p class="placeholder-meta">${artwork.artist} ‚Ä¢ ${artwork.year}</p>
        <p class="placeholder-status">üñºÔ∏è Image Pending Acquisition</p>
      </div>
    `;

    return div;
  }

  /**
   * Render critic reviews
   */
  function renderCritiques(carousel) {
    const container = document.getElementById('critiques-panel');
    if (!container) return;

    // Clear previous content
    container.innerHTML = '';

    const critics = carousel.getArtworkCritiques();
    if (!critics || critics.length === 0) {
      console.warn('‚ö† No critics found for this artwork');
      return;
    }

    // Render up to MAX_CRITICS_VISIBLE
    const visibleCritics = critics.slice(0, CONFIG.MAX_CRITICS_VISIBLE);

    visibleCritics.forEach((critique, index) => {
      const criticPanel = createCriticPanel(critique, carousel.personas);
      container.appendChild(criticPanel);
    });

    console.log(`‚úì Rendered ${visibleCritics.length} critic reviews`);
  }

  /**
   * Create a single critic panel element
   */
  function createCriticPanel(critique, personas) {
    const panel = document.createElement('article');
    panel.className = 'critique-panel';
    panel.setAttribute('data-reveal', ''); // Enable scroll-reveal animation
    panel.dataset.personaId = critique.personaId;
    panel.dataset.artworkId = critique.artworkId; // Store artwork ID for event handler access

    // Find persona info
    const persona = personas.find(p => p.id === critique.personaId) || {};

    // Get artwork for image reference processing
    const artwork = window.VULCA_DATA?.artworks?.find(a => a.id === critique.artworkId);

    // Header
    const header = document.createElement('div');
    header.className = 'critique-header';

    const nameEl = document.createElement('h3');
    nameEl.className = 'critique-author';

    // Bilingual name display
    const nameZh = document.createElement('span');
    nameZh.lang = 'zh';
    nameZh.textContent = persona.nameZh || 'Êú™Áü•';

    const nameEn = document.createElement('span');
    nameEn.lang = 'en';
    nameEn.textContent = persona.nameEn || 'Unknown';

    nameEl.appendChild(nameZh);
    nameEl.appendChild(nameEn);

    const periodEl = document.createElement('p');
    periodEl.className = 'critique-period';

    // Bilingual period display
    const periodZh = document.createElement('span');
    periodZh.lang = 'zh';
    periodZh.textContent = persona.period || persona.periodZh || '';

    const periodEn = document.createElement('span');
    periodEn.lang = 'en';
    periodEn.textContent = persona.periodEn || persona.period || '';

    periodEl.appendChild(periodZh);
    periodEl.appendChild(periodEn);

    header.appendChild(nameEl);
    header.appendChild(periodEl);
    panel.appendChild(header);

    // Text content (with image reference support)
    const textEl = document.createElement('p');
    textEl.className = 'critique-text';
    const textId = `critique-text-${critique.personaId}-${critique.artworkId}`;
    textEl.id = textId;

    // Use English or Chinese based on current language
    const lang = document.documentElement.getAttribute('data-lang') || 'zh';
    const text = lang === 'en' ? critique.textEn : critique.textZh;
    const fullText = text || '';

    // Store plain text
    panel.dataset.fullTextPlain = fullText;

    // Process with CritiqueParser if available
    if (window.CritiqueParser && artwork) {
      try {
        // Convert [img:id] to <a> tags
        const processedHTML = window.CritiqueParser.renderImageReferences(fullText, artwork, {
          linkClass: 'image-reference-link',
          showImageTitle: false,
          invalidClass: 'image-reference-invalid'
        });

        // Truncate while preserving HTML
        const truncatedHTML = truncateHTML(processedHTML, 150);

        // Store both versions for expand/collapse
        panel.dataset.fullTextProcessed = processedHTML;
        panel.dataset.truncatedProcessed = truncatedHTML;

        // Render truncated HTML
        textEl.innerHTML = truncatedHTML;

        console.log(`[Gallery Hero] Processed image references for ${critique.personaId}`);
      } catch (error) {
        console.error('[Gallery Hero] Failed to process image references:', error);
        // Fallback to plain text
        textEl.textContent = truncateText(fullText, 150);
      }
    } else {
      // Fallback: plain text (CritiqueParser not available)
      if (!window.CritiqueParser) {
        console.warn('[Gallery Hero] CritiqueParser not available, using plain text');
      }
      textEl.textContent = truncateText(fullText, 150);
    }

    panel.appendChild(textEl);

    // Toggle button for expand/collapse
    const toggleBtn = document.createElement('button');
    toggleBtn.className = 'critique-toggle-btn';
    toggleBtn.textContent = 'Â±ïÂºÄ ‚ñº';
    toggleBtn.setAttribute('aria-expanded', 'false');
    toggleBtn.setAttribute('aria-label', 'Â±ïÂºÄËØÑËÆ∫ÂÖ®Êñá');
    toggleBtn.setAttribute('aria-controls', textId);

    toggleBtn.addEventListener('click', () => {
      toggleCritiqueExpansion(panel, textEl, toggleBtn);
    });

    panel.appendChild(toggleBtn);

    // Attach click handlers to image reference links
    if (window.CritiqueParser && artwork && panel.dataset.fullTextProcessed) {
      setTimeout(() => {
        const links = textEl.querySelectorAll('.image-reference-link');

        if (links.length === 0) {
          console.log(`[Gallery Hero] No image reference links in ${critique.personaId}'s critique`);
          return;
        }

        links.forEach(link => {
          link.addEventListener('click', (e) => {
            e.preventDefault();
            const imageId = link.dataset.imageId;
            console.log(`[Gallery Hero] Image link clicked: ${imageId}`);
            handleImageReferenceClick(imageId, artwork);
          });
        });

        console.log(`[Gallery Hero] Attached ${links.length} image reference handlers for ${critique.personaId}`);
      }, 0);
    }

    // RPAIT scores
    if (critique.rpait) {
      const rpaitEl = createRPAITDisplay(critique.rpait);
      panel.appendChild(rpaitEl);
    }

    // Set background color based on persona
    if (persona.color) {
      panel.style.borderLeftColor = persona.color;
    }

    return panel;
  }

  /**
   * Create RPAIT score display
   */
  function createRPAITDisplay(rpait) {
    const container = document.createElement('div');
    container.className = 'critique-rpait';

    const label = document.createElement('span');
    label.className = 'rpait-label';
    label.textContent = 'RPAIT: ';
    container.appendChild(label);

    ['R', 'P', 'A', 'I', 'T'].forEach(dimension => {
      const score = rpait[dimension] || 0;
      const scoreEl = document.createElement('span');
      scoreEl.className = `rpait-score rpait-${dimension}`;
      scoreEl.textContent = `${dimension}: ${score}`;
      container.appendChild(scoreEl);
    });

    return container;
  }

  /**
   * Update the artwork indicator (X of 4)
   */
  function updateIndicator(carousel) {
    const currentEl = document.getElementById('artwork-current');
    const totalEl = document.getElementById('artwork-total');

    if (currentEl) {
      currentEl.textContent = carousel.getCurrentIndex() + 1;
    }

    if (totalEl) {
      totalEl.textContent = carousel.getArtworkCount();
    }
  }

  /**
   * Render dot indicators for all artworks
   */
  function renderDots(carousel) {
    const container = document.getElementById('artwork-dots');
    if (!container) return;

    // Clear previous dots
    container.innerHTML = '';

    const artworks = carousel.artworks;
    const currentIndex = carousel.getCurrentIndex();

    artworks.forEach((artwork, index) => {
      const dot = document.createElement('button');
      dot.className = 'dot';
      if (index === currentIndex) {
        dot.classList.add('active');
      }
      dot.setAttribute('data-index', index);
      dot.setAttribute('aria-label', `Artwork ${index + 1}`);
      dot.textContent = `${index + 1}`;

      // Click to navigate
      dot.addEventListener('click', (e) => {
        e.preventDefault();
        carousel.goTo(index);
      });

      container.appendChild(dot);
    });

    console.log(`‚úì Rendered ${artworks.length} dot indicators`);
  }

  /**
   * Handle click on image reference link in critique text
   * Navigates to the referenced image in the artwork carousel (if multi-image)
   */
  function handleImageReferenceClick(imageId, artwork) {
    console.log(`[Gallery Hero] Image reference clicked: ${imageId}`);

    // Find the carousel instance in the artwork-image-container
    const container = document.getElementById('artwork-image-container');
    if (!container) {
      console.warn('[Gallery Hero] No artwork container found');
      return;
    }

    // Check if this artwork has a multi-image carousel
    if (!window.ImageCompat) {
      console.warn('[Gallery Hero] ImageCompat not available');
      return;
    }

    const images = window.ImageCompat.getArtworkImages(artwork);

    if (images.length <= 1) {
      // Single image artwork - no carousel navigation needed
      console.log('[Gallery Hero] Single image artwork, no carousel to navigate');
      return;
    }

    // Find the image index
    const imageIndex = images.findIndex(img => img.id === imageId);
    if (imageIndex === -1) {
      console.warn(`[Gallery Hero] Image ${imageId} not found in artwork images`);
      return;
    }

    // Trigger carousel navigation by dispatching custom event to container
    const event = new CustomEvent('carousel:navigateTo', {
      detail: { imageIndex, imageId },
      bubbles: true
    });
    container.dispatchEvent(event);

    console.log(`[Gallery Hero] Dispatched navigation event to index ${imageIndex} (${imageId})`);

    // Scroll to carousel (smooth scroll)
    container.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

  return {
    init: init,
    render: render
  };
})();

console.log('‚úì Gallery hero renderer module loaded');
